<!--
Generated by agent-gov. Edits inside managed blocks may be overwritten by sync.
Local addenda below is project-owned and will not be overwritten.
-->
<!-- GOV:BEGIN id=doc-constitution version=HEAD sha256=8cc18869116253dcc6eddf22f4434af9f71b7229d4d14a3eb235208dc3bd8d31 sourceRepo=/Users/bsmith/Developer/github.com/BennettSmith/agent-governance-strategy sourceRef=HEAD sourceCommit=b91043670a8e9629bf9496ee651815d1b7e8725e -->

This document defines non‑negotiable rules for governance and collaboration, shared across profiles.

## Decision-making (core)

- Architectural decisions are captured explicitly when they affect system shape or long-term constraints.
- All work is planned before implementation and documented in markdown.
- Decisions favor clarity, testability, and long-term evolvability over short-term convenience.

## Default preferences (core, not hard rules)

- Explicit boundary types are preferred over leaking internal models.
- Prefer dependency inversion over direct instantiation.
- Prefer constructor-based injection over global state.
- Prefer explicit data flow over implicit framework behavior.
- Prefer small, reviewable changes over large refactors.

## Legacy refactoring protocol (core)

Legacy code may not yet follow the target architecture. Refactoring legacy code is permitted, but must be done in a way that is **orderly, reversible, and separated from behavior change**.

### Definitions

- **Refactor**: An internal restructure that preserves externally observable behavior at defined boundaries (persistence contracts, API interactions, and other profile-defined external boundaries).
- **Behavior change**: Any change that alters externally observable behavior at those boundaries. Behavior changes are features/fixes, not refactors.

### Separation rules

- Refactors and behavior changes must not be mixed in the same branch or pull request.
- Refactor branches should use the `refactor/` prefix; behavior-change branches use `feat/` or `fix/`; documentation branches should use `docs/`.

### Required workflow (repeat for each step)

- **Lock behavior**: Add characterization/contract/golden-master tests at the boundary you intend to preserve.
- **Introduce a seam**: Add an adapter/facade/port or boundary that lets you change internals without spreading violations.
- **Refactor behind the seam**: Make a small internal change that keeps prior behavior intact.
- **Run quality gates**: All required checks must pass for each step.
- **Checkpoint**: Record progress in the branch plan; keep steps small enough that a revert is safe and cheap.

### Approved patterns

See `Docs/Refactoring/Legacy-Refactoring-Playbook.md` for the approved patterns and checklists, including:

- Strangler Fig
- Branch by Abstraction
- Parallel Change / Expand–Contract
- “Seam first” refactoring
- Sprout method/class

## Agent rules (core)

- All work is performed in feature branches.
- Work proceeds in small, incremental steps aligned to a written plan.
- Plans must be stored in-repo at `Docs/Plans/<branch-name>.md` and kept up to date during development.
- Test-Driven Development is the default mode of work. This means tests come first; before code changes.
- Quality gates define completion, not code presence.
- Agents must stop after completing each planned task and request manual acceptance.
- Manual acceptance includes an explicit final approval request before the final PR wrap-up commit (recommended phrase: `APPROVAL REQUEST (final wrap-up): Please approve the final PR wrap-up commit.`).
- Agents may only mark a task complete in the plan and create a checkpoint commit after:
  - explicit human approval
  - all quality gates passing
- Agents must mark tasks completed in the plan once approved.
- Agents must never merge changes.
- Humans are responsible for acceptance, direction, and merge decisions.

## Conflict resolution (core)

- `Non-Negotiables.md` overrides all other governing documents.
- `Architecture.md` overrides `Constitution.md` on matters of system shape.
- `Constitution.md` guides behavior when other documents are silent.
- In case of ambiguity, stop work and ask for human direction.

## Architectural identity (backend-go-hex)

- Backend Go microservice.
- Hexagonal architecture (ports and adapters).
- API-first integration with external contracts (OpenAPI/gRPC/async messages) depending on the service profile.
- Infrastructure and transport are replaceable details, not the core of the system.

## Fundamental rules (backend-go-hex)

- Inbound adapters (HTTP/gRPC/consumers) must depend on application ports, not on domain internals.
- Outbound adapters (DB, queues, external APIs) must be invoked via outbound ports/interfaces.
- Business rules live in domain/application code, not in handlers/controllers/framework glue.
<!-- GOV:END id=doc-constitution -->

## Local Addenda (project-owned)

<!-- Project-owned notes, exceptions, and platform-specific adaptations go here. -->
