package builder

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"agent-governance-strategy/tools/gov/internal/managedblocks"
	"agent-governance-strategy/tools/gov/internal/profile"
	"agent-governance-strategy/tools/gov/internal/source"
)

type BuildOptions struct {
	OutDir   string
	DocsRoot string

	CacheDir string

	SourceRepo string
	SourceRef  string
	ProfileID  string

	MarkerPrefix   string
	AddendaHeading string
}

type BuildResult struct {
	DocsWritten       int
	ExtraFilesWritten int
	SourceCommit      string
}

func Build(ctx context.Context, opts BuildOptions) (BuildResult, error) {
	if strings.TrimSpace(opts.OutDir) == "" {
		return BuildResult{}, fmt.Errorf("out dir is required")
	}
	if strings.TrimSpace(opts.DocsRoot) == "" {
		opts.DocsRoot = "."
	}
	if strings.TrimSpace(opts.MarkerPrefix) == "" {
		opts.MarkerPrefix = "GOV"
	}
	if strings.TrimSpace(opts.AddendaHeading) == "" {
		opts.AddendaHeading = "Local Addenda (project-owned)"
	}

	src, err := source.Fetch(ctx, source.FetchOptions{
		RepoURL:  opts.SourceRepo,
		Ref:      opts.SourceRef,
		CacheDir: opts.CacheDir,
	})
	if err != nil {
		return BuildResult{}, err
	}

	manifestPath := filepath.Join(src.CheckoutDir, "Governance", "Profiles", opts.ProfileID, "profile.yaml")
	m, err := profile.LoadManifest(manifestPath)
	if err != nil {
		return BuildResult{}, err
	}

	baseOut := filepath.Clean(filepath.Join(opts.OutDir, opts.DocsRoot))
	if err := os.MkdirAll(baseOut, 0o755); err != nil {
		return BuildResult{}, err
	}

	var res BuildResult
	for _, doc := range m.Documents {
		content, err := assembleFragments(doc.Fragments, filepath.Dir(manifestPath))
		if err != nil {
			return BuildResult{}, fmt.Errorf("assemble %s: %w", doc.Output, err)
		}
		blockID := managedBlockIDForDoc(doc.Output)
		meta := map[string]string{
			"id":          blockID,
			"version":     opts.SourceRef,
			"sourceRepo":  src.SourceRepo,
			"sourceRef":   src.SourceRef,
			"sourceCommit": src.SourceCommit,
			"sha256":      managedblocks.SHA256Hex(content),
		}

		outDoc := strings.Join([]string{
			"<!--",
			"Generated by agent-gov. Edits inside managed blocks may be overwritten by sync.",
			"Local addenda below is project-owned and will not be overwritten.",
			"-->",
			managedblocks.FormatBeginMarker(opts.MarkerPrefix, meta),
			content,
			managedblocks.FormatEndMarker(opts.MarkerPrefix, blockID),
			"",
			"## " + opts.AddendaHeading,
			"",
			"<!-- Project-owned notes, exceptions, and platform-specific adaptations go here. -->",
			"",
		}, "\n")

		outPath := filepath.Join(baseOut, doc.Output)
		if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
			return BuildResult{}, err
		}
		if err := os.WriteFile(outPath, []byte(outDoc), 0o644); err != nil {
			return BuildResult{}, err
		}
		res.DocsWritten++
	}

	// Templates and playbooks are extra files.
	for _, t := range append(m.Templates, m.Playbooks...) {
		srcPath := filepath.Join(filepath.Dir(manifestPath), t.Source)
		b, err := os.ReadFile(srcPath)
		if err != nil {
			return BuildResult{}, fmt.Errorf("read %s: %w", srcPath, err)
		}
		outPath := filepath.Join(baseOut, t.Output)
		if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
			return BuildResult{}, err
		}
		if err := os.WriteFile(outPath, b, 0o644); err != nil {
			return BuildResult{}, err
		}
		res.ExtraFilesWritten++
	}

	res.SourceCommit = src.SourceCommit
	return res, nil
}

func assembleFragments(fragmentPaths []string, baseDir string) (string, error) {
	var parts []string
	for _, rel := range fragmentPaths {
		p := filepath.Clean(filepath.Join(baseDir, rel))
		b, err := os.ReadFile(p)
		if err != nil {
			return "", err
		}
		parts = append(parts, strings.TrimRight(string(b), "\n"))
	}
	return strings.Join(parts, "\n\n"), nil
}

func managedBlockIDForDoc(output string) string {
	base := output
	base = strings.TrimSuffix(base, filepath.Ext(base))
	base = strings.ToLower(base)
	base = strings.ReplaceAll(base, "_", "-")
	base = strings.ReplaceAll(base, " ", "-")
	var b strings.Builder
	for _, r := range base {
		switch {
		case r >= 'a' && r <= 'z':
			b.WriteRune(r)
		case r >= '0' && r <= '9':
			b.WriteRune(r)
		case r == '-':
			b.WriteRune(r)
		}
	}
	id := strings.Trim(b.String(), "-")
	if id == "" {
		return "doc"
	}
	return "doc-" + id
}

